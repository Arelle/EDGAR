{"version":3,"file":"fetch-merge.bundle.782da99e117204037950.min.js","mappings":"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","sources":["webpack://ixviewer-2/webpack/runtime/chunk loaded","webpack://ixviewer-2/webpack/runtime/startup chunk dependencies","webpack://ixviewer-2/./src/ts/interface/fact.ts","webpack://ixviewer-2/./src/ts/constants/constants.ts","webpack://ixviewer-2/./src/ts/helpers/utils.ts","webpack://ixviewer-2/./src/ts/helpers/fact-id-allocator.ts","webpack://ixviewer-2/./src/ts/fetch-merge/merge-data-utils.ts","webpack://ixviewer-2/./src/ts/fetch-merge/prepare-inline-doc.ts","webpack://ixviewer-2/./src/ts/fetch-merge/fetch-merge.ts","webpack://ixviewer-2/./src/ts/workers/workers.ts","webpack://ixviewer-2/webpack/bootstrap","webpack://ixviewer-2/webpack/runtime/define property getters","webpack://ixviewer-2/webpack/runtime/ensure chunk","webpack://ixviewer-2/webpack/runtime/get javascript chunk filename","webpack://ixviewer-2/webpack/runtime/get mini-css chunk filename","webpack://ixviewer-2/webpack/runtime/hasOwnProperty shorthand","webpack://ixviewer-2/webpack/runtime/make namespace object","webpack://ixviewer-2/webpack/runtime/publicPath","webpack://ixviewer-2/webpack/runtime/importScripts chunk loading","webpack://ixviewer-2/webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn Promise.all([\n\t\t__webpack_require__.e(870),\n\t\t__webpack_require__.e(585)\n\t]).then(next);\n};","import { Xbrltype, reference } from \"./meta\";\n\nexport type Facts = { key: string, value: SingleFact } & Record<string, string>;\n\nexport interface SingleFact {\n    contextRef: string;\n    name: string;\n    ix: string;\n    id: string;\n    value?: string;\n    isAmountsOnly: boolean;\n    isTextOnly: boolean;\n    isNegativeOnly: boolean;\n    isHTML: boolean;\n    isSelected: boolean;\n    period: string;\n    periodDates?: string[];\n    scale: string | null;\n    decimals?: Decimals | null;\n    decimalsVal?: number | null;\n    sign: string | null;\n    footnote: null | string;\n    isEnabled: boolean;\n    isHighlight: boolean;\n    references: Array<ReferenceAsArray> | null;\n    calculations: Array<Calculation[]>;\n    labels: LabelElement[];\n    xbrltype: string;\n    localname: string;\n    nsuri: string;\n    presentation: string[];\n    raw?: string;\n    format?: null | string;\n    isAdditional?: boolean;\n    isCustom?: boolean;\n    file: string | null;\n    unitRef?: string;\n    measure?: string;\n    balance?: Balance;\n    segment?: Array<SegmentClass[] | SegmentClass>;\n    isContinued: boolean;\n    continuedIDs: Array<string>;\n    filterContent: {\n        content: string,\n        labels: string,\n        definitions: string,\n\n    }\n    \"xsi:nil\"?: string;\n    \"xml:lang\"?: string;\n}\n\n/** somehow, an object in fetch-merge metamorphosizes from SingleFact into this */\nexport interface SingleFact2\n{\n    name: string;\n    segment: [{ dimension: string, axis: string }];\n    references: reference[];\n    calculations: [{ label: string, value: string }] | [];\n    labels: string[];\n    filterContent: { labels: string; definitions: string; };\n    balance: string;\n    xbrltype: Xbrltype | null;\n    localname: string | null;\n    nsuri: string | null;\n    presentation: string[] | null | undefined;\n}\n\nexport enum Balance {\n    Credit = \"Credit\",\n    Debit = \"Debit\",\n}\n\nexport interface Calculation {\n    label: LabelEnum;\n    value: string;\n}\n\nexport enum LabelEnum\n{\n    Balance = \"Balance\",\n    Parent = \"Parent\",\n    Section = \"Section\",\n    Weight = \"Weight\",\n}\n\nexport enum Decimals\n{\n    Tens = \"Tens\",\n    Hundreds = \"Hundreds\",\n    Thousands = \"Thousands\",\n    TenThousands = \"Ten Thousands\",\n    HundredThousands = \"Hundred Thousands\",\n    Millions = \"Millions\",\n    TenMillions = \"Ten Millions\",\n    HundredMillions = \"Hundred Millions\",\n    Billions = \"Billions\",\n    TenBillions = \"Ten Billions\",\n    HundredBillions = \"Hundred Billions\",\n    Trillions = \"Trillions\",\n\n    Tenths = \"Tenths\",\n    Hundredths = \"Hundredths\",\n    Thousandths = \"Thousandths\",\n    TenThousandths = \"Ten Thousandths\",\n    HundredThousandths = \"Hundred Thousandths\",\n    Millionths = \"Millionths\",\n}\n\nexport interface LabelElement {\n    Documentation: string;\n    Label: string;\n    \"Terse Label\"?: string;\n    \"Verbose Label\"?: string;\n    \"Negated Terse Label\"?: string;\n    \"Total Label\"?: string;\n    \"Negated Label\"?: string;\n    \"Period End Label\"?: string;\n    \"Period Start Label\"?: string;\n    \"Negated Period End Label\"?: string;\n    \"Negated Period Start Label\"?: string;\n    \"Negated Total Label\"?: string;\n}\n\n// TODO: ask knowledge bearers if we maybe we create distint orders for each taxonomy body (fasb, sec, etc...) as they each probably have their own properties.\nexport interface Reference {\n    Publisher: string;\n    Name: string;\n    Number?: string;\n    IssueDate?: string;\n    Chapter?: string,\n    Article?: string;\n    Note?: string;\n    Section?: string;\n    Subsection?: string;\n    Topic?: string;\n    SubTopic?: string;\n    Paragraph?: string;\n    Subparagraph?: string;\n    Clause?: string,\n    Subclause?: string,\n    Example?: string,\n    Page?: string,\n    Exhibit?: string,\n    Footnote?: string,\n    Sentence?: string;\n    URI?: string;\n    URIDate?: string,\n}\n\ninterface RefProp {\n    string: string,\n}\nexport interface ReferenceAsArray {\n    ReferenceMember: Array<RefProp>\n}\n\nexport interface SegmentClass {\n    axis?: string;\n    dimension: string;\n    dimensionLabel: string;\n    type: string;\n    member: null; // value\n    memberLabel?: string;\n}\n","/* Created by staff of the U.S. Securities and Exchange Commission.\n * Data and content created by government employees within the scope of their employment\n * are not subject to domestic copyright protection. 17 U.S.C. 105.\n */\n\nimport { Reference } from \"../interface/fact\";\nimport { FormInformation } from \"../interface/form-information\";\nimport { InlineFileMeta, InstanceFile } from \"../interface/instance-file\";\nimport { Section } from \"../interface/meta\";\n\n//Not really used (see comment below)\ntype MetaDocument = any;\n\nexport const Constants =\n{\n\tversion: \"25.3\",\n\tfeatureSet: \"plus\",\n\tappStart: 0,\n\tloadPhaseComplete: 0,\n\n\tappWindow: (() => {\n\t\tif (typeof window == 'undefined') return {} as Window;\n\t\t// redirect iframe\n\t\tif (!!window.frameElement && window.frameElement.id === \"ixvFrame\") {\n\t\t\treturn window.parent;\n\t\t}\n\t\t// Note: workstation iframe has id \"dispDocFrame\", I don't think we need to handle it though since the iframe\n\t\t// in that cases seems intended to work as \"subwindow\" and links should open in the iframe (?)\n\t\treturn window;\n\t})(),\n\n\tloadedViaRedirect: (() => {\n\t\tif (typeof window == 'undefined') return false;\n\t\t// redirect iframe\n\t\tif (!!window.frameElement && window.frameElement.id === \"ixvFrame\") {\n\t\t\treturn true;\n\t\t}\n\t})(),\n\n\t// holds array of objects { perfMetric, moduleTime, totalElapsedTime }\n\tperfTableJs: [] as object[],\n\tperfTableDom: [] as object[],\n\telapsedPerfTable: [] as object[],\n\tdiscretePerfTable: [] as object[],\n\tlogPerfParam: false,\n\n\tunused: 'test',\n\taxesCount: 0,\n\tmembersCount: 0,\n\tmemberLimit: 750, // too many affects search index performance and eats a lot of mem\n\n\tgetSearchCriteria: {} as { options: { indexOf: (x: any) => number }, regex: RegExp },\n\n\tisNcsr: false,\n\n\tscrollPosition: typeof window !== 'undefined' && window.localStorage.getItem(\"scrollPosition\") || \"start\",\n\n\thoverOption: typeof window !== 'undefined' && window.localStorage.getItem(\"hoverOption\") === \"true\" || false,\n\n\tgetHTMLAttributes: {} as Record<any, unknown>,\n\n\tgetPaginationPerPage: 10,\n\n\tgetHtmlOverallFactsCount: null as string | null,\n\n\tgetMetaSourceDocuments: [] as string[],\n\n\tgetMetaTags: [] as unknown[],\n\n\tgetInstances: [] as InstanceFile[],\n\n\tgetCurrentInstance: () => {\n\t\treturn Constants.getInstances.find(inst => inst.current);\n\t},\n\n\tgetInlineFiles: [] as InlineFileMeta[],\n\n\tsections: [] as Section[],\n\n\tsetSections: (sections: Array<Section>): void => {\n\t\tif (sections) {\n\t\t\tConstants.sections = sections;\n\t\t\tsessionStorage.setItem('sections', JSON.stringify(sections));\n\t\t}\n\t},\n\n\tgetSectionsFromSessionStorage: (): Section[] => {\n\t\tconst sectionsFromLocal = sessionStorage.getItem('sections');\n\t\treturn JSON.parse(sectionsFromLocal || '[]') as Section[];\n\t},\n\n\tgetStdRef: {} as Record<string, Reference>,\n\n\tgetFormInformation: {} as FormInformation,\n\n\tgetMetaCustomPrefix: null as string | null,\n\n\t//These are never accessed outside of old unit tests\n\tgetMetaDts: null as MetaDocument | null,\n\tgetMetaDocuments: (input: string): MetaDocument | null => {\n\t\tif (input && typeof input === \"string\") {\n\t\t\treturn Constants.getMetaDts && Constants.getMetaDts[input]\n\t\t\t\t? Constants.getMetaDts[input]\n\t\t\t\t: null;\n\t\t}\n\n\t\treturn null;\n\t},\n\n\tgetScrollPosition: (): number => {\n\t\tconst currentScrollPosition = document.getElementById('dynamic-xbrl-form')!.scrollTop as number;\n\t\treturn currentScrollPosition;\n\t},\n\n\tgetNavBarsHeight: (): number => {\n\t\treturn document.querySelector<HTMLElement>('div[id=\"topNavs\"]')?.offsetHeight || 0;\n\t},\n\n\tsideBarPaginationState: {pageNumber: 0, totalPages: 0},\n\n};\n","/* Created by staff of the U.S. Securities and Exchange Commission.\n * Data and content created by government employees within the scope of their employment \n * are not subject to domestic copyright protection. 17 U.S.C. 105.\n */\n\nimport DOMPurify from \"dompurify\";\nimport { Constants } from \"../constants/constants\";\nimport { toBottomOfInlineDoc } from \"../pagination/inlineDocPagination\";\n\nexport const cleanSubstring = (orig: string, from: string, to: string) => {\n    return orig.substring(orig.search(from), orig.search(to) + to.length);\n}\n\nexport const convertToSelector = (input: string, sanitize = true) => {\n    const normalizedSelector = input.replaceAll('/', '-')\n        .replaceAll(' ', '-')\n        .replaceAll('#', '-')\n        .replaceAll('.', '-')\n    if (sanitize)\n        return DOMPurify.sanitize(normalizedSelector);\n    else {\n        return normalizedSelector;\n    }\n}\n\n// WIP\nexport const xmlToDom = (xmlNode: Node): Node | null => {\n\n    if (!PRODUCTION) {\n        console.log('node.nodeType', xmlNode.nodeType)\n        console.log('node', xmlNode)\n    }\n    if (xmlNode.nodeType === 1) { // Element node\n        const element = document.createElement(xmlNode.nodeName)\n\n        // add attributes\n        if (xmlNode instanceof Element) {\n            for (const attr of xmlNode.attributes) {\n                element.setAttributeNS(attr.namespaceURI, attr.nodeName, attr.nodeValue || \"\");\n            }\n        }\n\n        // recursively process child nodes\n        for (const child of xmlNode.childNodes) {\n            const childNode = xmlToDom(child);\n            if (childNode) {\n                element.appendChild(childNode);\n            }\n        }\n\n        return element;\n    } else if (xmlNode.nodeType === 3) { // Text node\n        return document.createTextNode(xmlNode.nodeValue || \"\");\n    }\n    return null;\n}\n\n// WIP\nexport const findAllTagTypeInMarkupString = (markup: string, openTag: string, closeTag: string) => {\n    const allTags: string[] = [];\n\n    const startTagRegex = RegExp(openTag, 'gi')\n    let startTagResults = startTagRegex.exec(markup);\n    const footnoteStartIndices: number[] = [];\n    while (startTagResults) {\n        footnoteStartIndices.push(startTagResults.index);\n        startTagResults = startTagRegex.exec(markup);\n    }\n\n    const endTagRegex = RegExp(closeTag, 'gi');\n    let endTagResults = endTagRegex.exec(markup);\n    const footnoteEndIndices: number[] = [];\n    while (endTagResults) {\n        footnoteEndIndices.push(endTagResults.index + closeTag.length);\n        endTagResults = endTagRegex.exec(markup);\n    }\n\n    footnoteStartIndices.forEach((start, indexInArrayOfStarts) => {\n        const pluckedFootnote = markup.substring(start, footnoteEndIndices[indexInArrayOfStarts]);\n        allTags.push(pluckedFootnote);\n    });\n\n    return allTags;\n}\n\nexport function ixScrollTo(sectionElem: HTMLElement): void {\n    if (elemNearBottom(sectionElem)) {\n        toBottomOfInlineDoc();\n    } else {\n        sectionElem?.scrollIntoView({ behavior: \"smooth\", block: \"start\", inline: \"nearest\" });\n    }\n}\n\n/**\n * Determine if the provided element is within 1vh of the bottom of the screen.\n * @param target The Element to which we should scroll.\n * @param parentElem Not the scrollable parent. Probably the first descendent thereof.  Needs to be full-height, non-scrollable.\n * @param scrollableParent An ancestor of `target` that scrolls.\n * @returns boolean\n */\nfunction elemNearBottom(target: HTMLElement, parentElem?: HTMLElement, scrollableParent?: HTMLElement): boolean {\n    if (!parentElem) {\n        const currentInstance = Constants.getInstances.find(element => element.current);\n        const currentXHTML = currentInstance?.docs.find(element => element.current);\n        if (currentXHTML?.slug) {\n            parentElem = document.querySelector<HTMLElement>(`section[filing-url=\"${currentXHTML?.slug}\"]`) || undefined;\n        }\n    }\n    if (!scrollableParent) {\n        const currentInstance = Constants.getInstances.find(element => element.current);\n        const currentXHTML = currentInstance?.docs.find(element => element.current);\n        if (currentXHTML?.slug) {\n            scrollableParent = document.getElementById('dynamic-xbrl-form') || undefined;\n        }\n    }\n\n    const viewHeight = scrollableParent?.offsetHeight || 0;\n    const parentHt = parentElem?.offsetHeight || 0;\n\n    let distTopOfTargetToTopOfScrollableParent = 0;\n    let currentElement = target;\n\n    while (currentElement && currentElement !== parentElem) {\n        distTopOfTargetToTopOfScrollableParent += currentElement.offsetTop || 0;\n        currentElement = currentElement.offsetParent as HTMLElement;\n    }\n\n    if (scrollableParent == document.getElementById('dynamic-xbrl-form')) {\n        distTopOfTargetToTopOfScrollableParent -= Constants.getNavBarsHeight();\n    }\n\n    return distTopOfTargetToTopOfScrollableParent > parentHt - viewHeight;\n}\n\nexport function isTruthy<T>(t: T): t is NonNullable<T> {\n    return Boolean(t);\n}\n\nexport function actionKeyHandler(event: KeyboardEvent): boolean {\n    const defaultActionKeys = ['Enter', 'Space', ' ']\n    if (event instanceof KeyboardEvent && !defaultActionKeys.includes(event.key))\n        return false;\n\n    stopPropPrevDefault(event);\n    return true;\n}\n\nexport function stopPropPrevDefault(event: Event): void {\n    event.stopPropagation();\n    event.preventDefault();\n}\n\n// Generic func that takes array of elements that up/down arrows will nav through\n// WIP\nexport function buildArrowKeyListenerForElems(elemSet: Node[]) : void {\n    console.log('elemSet', elemSet)\n    elemSet.forEach((elem, index) => {\n        elem.addEventListener('keyup', (event) => {\n            const keyEvent = <KeyboardEvent> event;\n            if (keyEvent.key == 'ArrowUp') {\n                if (index === 0) {\n                    (elemSet[elemSet.length - 1] as HTMLElement)?.focus();\n                } else {\n                    (elemSet[index - 1] as HTMLElement).focus();\n                }\n            }\n            if (keyEvent.key == 'ArrowDown') {\n                if (index === elemSet.length - 1) {\n                    (elemSet[0] as HTMLElement).focus();\n                } else {\n                    (elemSet[index + 1] as HTMLElement).focus();\n                }\n            }\n        });\n    })\n}\n","import { SingleFact } from \"../interface/fact\";\n\n/* Created by staff of the U.S. Securities and Exchange Commission.\n * Data and content created by government employees within the scope of their employment\n * are not subject to domestic copyright protection. 17 U.S.C. 105.\n */\n\n\n//For the facts in the HTML that have no IDs...\nexport class FactIdAllocator\n{\n    private facts: Map<string, SingleFact>;\n    private noIdFactMap: Map<string, Array<string>> | null = null;\n\n    constructor(facts: Map<string, SingleFact>)\n    {\n        this.facts = facts;\n    }\n\n    public getId(contextRef?: string | null, name?: string | null): string | null\n    {\n        if (this.noIdFactMap == null)\n        {\n            let m = new Map<string, Array<string>>();\n            this.noIdFactMap = [...this.facts.values()]\n                .map(({ id, name, contextRef}) => [JSON.stringify({ name, contextRef }), id])\n                .reduce((acc, [nameCtxref, id]) =>\n                {\n                    let idList = acc.get(nameCtxref) || [];\n                    idList.push(id);\n                    acc.set(nameCtxref, idList);\n\n                    return acc;\n                }, m);\n        }\n\n        const key = JSON.stringify({ name, contextRef });\n        return this.noIdFactMap.get(key)?.shift() || null;\n    }\n}\n","import { MetalinksReport, Section, SectionFact } from '../interface/meta';\nimport { convertToSelector } from \"../helpers/utils\";\nimport { FilingSummary, FilingSummReport } from '../interface/filing-summary';\n\n/**\n * Description\n * @param {any} filingSummary:any\n * @param {any} metaLinksReports:any\n * @returns {any} => Flatter array of metalinks reports (section items).\n */\nexport const buildSectionsArrayFlatter = (filingSummary:FilingSummary, metaLinksReports:MetalinksReport[], metaVersion:string) => {\n    // 'sections' and 'reports' are synonymous here\n    const filingSummaryReports: FilingSummReport[] = filingSummary.MyReports.Report;\n    let filingSummaryInputFiles = filingSummary.InputFiles.File;\n    if (!Array.isArray(filingSummaryInputFiles)) filingSummaryInputFiles = [filingSummaryInputFiles];\n    \n    const reportsContainStatements: boolean = filingSummaryReports\n        .filter(r => r.MenuCategory)\n        .map(r => r.MenuCategory._text?.toLowerCase())\n        .some((menuCategory: string) => {\n            return menuCategory == 'statement' || menuCategory == 'statements';\n        })\n\n    const addInstanceProps = (section: Section) => {\n        // Get Doc Name for instance header for sections\n        const isHtmIsh = (fileName: string) => {\n            return fileName.includes('.htm') || fileName.includes('.html') || fileName.includes('.xhtml');\n        }\n        const reportFileInfo = filingSummaryInputFiles.filter(file => {\n            if (file._attributes && file._attributes?.original && isHtmIsh(file._text)) {\n                return section.instanceHtm.includes(file._attributes.original)\n            }\n        });\n        if (reportFileInfo.length) {\n            section.instanceDocName = reportFileInfo[0]?._attributes?.doctype;\n        } else {\n            console.error(`Cannot find instance file in FilingsSummary inputfiles`);\n        }\n        return section;\n    }\n\n    const addFactProps = (section: Section) => {\n        section.fact = getFactAttrsFromAnchorProps(section) || undefined;\n        const mrFact = section.fact;\n        if (mrFact?.file && mrFact?.ancestors && mrFact?.name) {\n            // if an ancestor is a fact name eg \"sbs:SbsefOrglStrDescTextBlock\", need to dress as name attribute\n            const handleSpecialAncestors = mrFact.ancestors.map((a: string) => {\n                if (a.includes(':')) {\n                    if (a.includes('ix:continuation')) return ''; // skip continuation ancestors\n                    return `[name=\"${a}\"]`\n                } else {\n                    return a;\n                }\n            });\n            const ancestorsRelevant = handleSpecialAncestors.reverse().filter((a:string) => a !== \"html\").join(' ');\n            section.inlineFactSelector = `section[filing-url=\"${mrFact.file}\"] > ${ancestorsRelevant} [name=\"${mrFact.name}\"][contextref=\"${mrFact.contextRef}\"]`;\n        }\n        return section;\n    }\n\n    const getPositionFromFilingSumm = (metaReport:MetalinksReport) => {\n        let pos;\n        filingSummaryReports.forEach(fsRep => {\n            if (fsRep.ShortName._text === metaReport.shortName) {\n                pos = Number(fsRep.Position._text);\n            }\n        })\n        return pos;\n    }\n    const getMenuCategoryFromFilingSumm = (metaReport:MetalinksReport) => {\n        let menuCategory;\n        filingSummaryReports.find(fsRep => {\n            if (fsRep.ShortName._text === metaReport.shortName) {\n                menuCategory = fsRep.MenuCategory._text;\n            }\n        })\n        return menuCategory;\n    }\n\n    const sectionsArray = metaLinksReports.map((metaReport:MetalinksReport) => {\n        let section: Section = metaReport as unknown as Section;\n        if (Number(metaVersion) <= 2.1 || !section.menuCat) {\n            section.menuCat = getMenuCategoryFromFilingSumm(metaReport) || section.subGroupType || section.groupType;\n        }\n        if (metaReport.menuCat && metaReport.shortName) {\n            section = addInstanceProps(section);\n            section = addFactProps(section);\n            section.menuCatMapped = mapCategoryName(section.menuCat, reportsContainStatements) || \"\";\n            section.position = getPositionFromFilingSumm(metaReport); // as a fallback if there's no \"order\" prop (rare)\n            section.domId = `sectionDoc-${convertToSelector(section.instanceDocName, false)}`\n\n            return section;\n        } else {\n            if (!PRODUCTION) {\n                console.warn('Cannot determine Section menuCat');\n            }\n        }\n    }).filter((section): section is Section => !!(section?.fact && section.menuCatMapped));\n    return sectionsArray || [];\n}\n\nexport const getFactAttrsFromAnchorProps = (section: Section) => {\n    let fact: SectionFact | null = {};\n    fact.instance = section.instance; // number\n    // fact.menuCat = metaReport.menuCat;\n    if (section.uniqueAnchor) {\n        fact.name = section.uniqueAnchor.name;\n        fact.contextRef = section.uniqueAnchor.contextRef;\n        fact.file = section.uniqueAnchor.baseRef;\n        fact.ancestors = section.uniqueAnchor.ancestors;\n    } else if (section.firstAnchor) {\n        fact.name = section.firstAnchor.name;\n        fact.contextRef = section.firstAnchor.contextRef;\n        fact.file = section.firstAnchor.baseRef;\n        fact.ancestors = section.firstAnchor.ancestors;\n    } else {\n        if (!PRODUCTION) {\n            console.warn(`no linkable fact for section ${section.shortName} (no anchor data)`);\n        }\n        /* DOC: \"As I recall, the reason for the anchors computed during rendering was that \n                some internal rendering process detail gets lost that neither filing summary.xml \n                nor metalinks.json could preserve (I think it had to do with how chrome will insert \n                elements like <tbody> if they were missing in the input?), but since I cant \n                remember what that might be (its certainly not obvious) go ahead and try.\" -WH email 4/1/2024 \n        */\n        fact = null;\n    }\n    return fact;\n}\n\n/**\n * Description\n * @param {string} input: string\n * @returns {string} => (string) mapped menu category name || null\n * @description use only when there are no 'statement' menu categories\n */\nconst mapCategoryName = (input: string, isStandard: boolean): string | null => {\n    const lowerCaseKey = input.toLowerCase();\n\n    /*\n        'When the FilingSummary does not have any statement category reports for an instance, then the following mapping should be used.  \n        Reports is generic and covers all the other things that dont need their reports grouped into levels of detail.  \n        Statements used to be the general case (2008-2020) but now they are becoming the special case.' - WH Mar 29, 2024\n    */\n    const noStatementCatNameMap = {\n        \"cover\": \"Reports\",\n        \"document\": \"Reports\",\n        // \"statement\": n/a\n        // \"Statements\": n/a\n        \"disclosure\": \"Reports\",\n        \"notes\": \"Reports\",\n        \"policies\": \"Reports\", /* very unlikely to happen */\n        \"tables\": \"Reports\", /* very unlikely to happen */\n        \"details\": \"Details\",/* example here {baseUrl}/oef24/oef05/out/FilingSummary.htm# */\n        \"prospectus\": \"Prospectus\",\n        \"rr_summaries\": \"RR Summaries\",/* example here {baseUrl}/oef24/oef13/out/FilingSummary.htm we no longer make fancy menus for these */\n        \"fee_exhibit\": \"RR Summaries\",\n        \"risk/return\": \"RR Summaries\"\n    };\n    const standardCatNameMap = {\n        \"cover\": \"Cover\",\n        \"document\": \"Document & Entity Information\",\n        \"statement\": \"Financial Statements\",\n        \"statements\": \"Financial Statements\",\n        \"disclosure\": \"Notes to the Financial Statements\",\n        \"notes\": \"Notes to Financial Statements\", // is \"the\" intentionally omitted?  Probably\n        \"policies\": \"Accounting Policies\",\n        \"tables\": \"Notes Tables\",\n        \"details\": \"Notes Details\",\n        \"prospectus\": \"Prospectus\",\n        \"rr_summaries\": \"RR Summaries\",\n        \"fee_exhibit\": \"RR Summaries\",\n        \"risk/return\": \"RR Summaries\"\n    };\n\n    if (isStandard) {\n        if (lowerCaseKey in standardCatNameMap) {\n            return standardCatNameMap[lowerCaseKey as keyof typeof standardCatNameMap];\n        } else {\n            if (!PRODUCTION) {\n                console.info(`standardCatNameMap doesn't contain key: %c${lowerCaseKey}`, \"color: deepskyblue\");\n            }\n            return null;\n        }\n    } else {\n        if (lowerCaseKey in noStatementCatNameMap) {\n            return noStatementCatNameMap[lowerCaseKey as keyof typeof noStatementCatNameMap];\n        } else {\n            if (!PRODUCTION) {\n                console.info(`noStatementCatNameMap doesn't contain key: %c${lowerCaseKey}`, \"color: deepskyblue\");\n            }\n            return null;\n        }\n    }\n};\n\nexport function fetchText(url: string, init?: RequestInit): Promise<string | never> {\n    return fetch(url, init).then((response) => {\n        if (!response.ok) {\n            throw new Error(response.status.toString());\n        }\n\n        // Check the response headers to ensure the document is intended to be loaded inline.\n        const contentType = response.headers.get(\"content-type\");\n        if (!contentType) {\n            throw new Error(`Missing Content-Type. URL: ${url}`);\n        }\n        const permittedContentTypeExpression = /^(application\\/xhtml\\+xml|application\\/xml|text\\/html|text\\/xml)(\\s*;.*)?$/i;\n        if (!permittedContentTypeExpression.test(contentType)) {\n            throw new Error(`Invalid Content-Type. URL: ${url}, Content-Type: ${contentType}`);\n        }\n        const contentDisposition = response.headers.get(\"content-disposition\");\n        const permittedContentDispositionExpression = /^inline(\\s*;.*)?$/i;\n        if (contentDisposition && !permittedContentDispositionExpression.test(contentDisposition)) {\n            throw new Error(`Invalid Content-Disposition. URL: ${url}, Content-Disposition: ${contentDisposition}`);\n        }\n\n        return response.text();\n    });\n}\n\nexport function fetchJson<T = any>(url: string, init?: RequestInit): Promise<T | never> {\n    return fetch(url, init).then((response) => {\n        if (response.status >= 200 && response.status <= 299)\n            return response.json();\n        else\n            throw new Error(response.status.toString());\n    });\n}\n\nexport function setScaleInfo(scale: string | number | undefined): string | null {\n    const scaleOptions: Record<string, string> = {\n        0: \"Zero\",\n        1: \"Tens\",\n        2: \"Hundreds\",\n        3: \"Thousands\",\n        4: \"Ten thousands\",\n        5: \"Hundred thousands\",\n        6: \"Millions\",\n        7: \"Ten Millions\",\n        8: \"Hundred Millions\",\n        9: \"Billions\",\n        10: \"Ten Billions\",\n        11: \"Hundred Billions\",\n        12: \"Trillions\",\n        \"-1\": \"Tenths\",\n        \"-2\": \"Hundredths\",\n        \"-3\": \"Thousandths\",\n        \"-4\": \"Ten Thousandths\",\n        \"-5\": \"Hundred Thousandths\",\n        \"-6\": \"Millionths\"\n    };\n    \n    return scaleOptions[scale || \"\"] || null;\n}\n","import * as c from \"cheerio\";\nimport { Cheerio, load } from \"cheerio\";\nimport { ILogObj, Logger } from \"tslog\";\nimport { FactIdAllocator } from \"../helpers/fact-id-allocator\";\nimport { XhtmlFileMeta } from \"../interface/instance-file\";\nimport { SingleFact } from \"../interface/fact\";\nimport { setScaleInfo } from \"./merge-data-utils\";\n\n\n/* Created by staff of the U.S. Securities and Exchange Commission.\n * Data and content created by government employees within the scope of their employment\n * are not subject to domestic copyright protection. 17 U.S.C. 105.\n */\n\n\nexport type XhtmlPrepData = {\n    docs: XhtmlFileMeta[];\n    facts: Map<string, SingleFact>;\n    customPrefix: string\n}\n\nexport type XhtmlPrepResponse = {\n    facts: Map<string, SingleFact>;\n    xhtml: string;\n}\n\n//TODO: rename this class\nexport class XhtmlPrepper {\n    private docs: XhtmlFileMeta[];\n    private facts: Map<string, SingleFact>;\n    private readonly customPrefix: string;\n    private readonly idAllocator: FactIdAllocator;\n\n    constructor({ docs, facts, customPrefix }: XhtmlPrepData) {\n        this.docs = docs;\n        this.facts = facts;\n        this.customPrefix = customPrefix;\n        this.idAllocator = new FactIdAllocator(this.facts);\n    }\n\n    public updateFactMapWithDocsData() {\n        const promises = [...this.docs]\n            .sort((a, b) => +b.current - +a.current)\n            .map((doc) =>\n                new Promise<void>((resolve) => {\n                    this.applyElementDataToFact(doc);\n                    resolve();\n                })\n            );\n\n        return Promise.all(promises);\n    }\n\n    \n\n    private applyElementDataToFact(doc: XhtmlFileMeta) {\n        let $ = load(doc.xhtml, {});\n        const factElements = Array.from($(`[contextRef]`));\n\n        for (let factElem of factElements) {\n            const id = $(factElem).attr(\"id\") || this.idAllocator.getId($(factElem).attr('contextref'), $(factElem).attr('name'));\n            if (id) {\n                this.updateMap(id, $(factElem), doc.slug);\n            }\n            else {\n                const log: Logger<ILogObj> = new Logger();\n                log.error(`Fact [name] && [contextRef] could not be located in the Map Object.`);\n            }\n        }\n    }\n\n    private updateMap(id: string, element: Cheerio<c.Element>, docSlug: string): string {\n        const fact = this.facts.get(id);\n        if (!fact) {\n            console.error(\"Cannot update map -- missing key:\", id);\n            return \"\";\n        }\n\n        this.facts.set(id,\n            {\n                ...fact,\n                raw: element.text(),\n                format: element.attr('format') ? element.attr('format') : null,\n                isAdditional: element.parents().prop('tagName').toLowerCase().endsWith(':hidden'),\n                isCustom: element.attr('name')?.split(':')[0].toLowerCase() === this.customPrefix,\n                isAmountsOnly: element.prop('tagName')?.split(':')[1].toLowerCase() === 'nonfraction',\n                isTextOnly: element.prop('tagName')?.split(':')[1].toLowerCase() === 'nonnumeric',\n                isNegativeOnly: element.attr('sign') === '-',\n                sign: (element.attr('sign') === '-') ? \"Negative\" : null,\n                file: docSlug,\n                scale: setScaleInfo(element.attr('scale')) || \"\",\n                continuedIDs: [],\n            });\n\n        return fact.id;\n    }\n}\n","import * as cheerio from 'cheerio';\nimport { Logger, ILogObj } from 'tslog';\nimport * as convert from 'xml-js';\nimport { cleanSubstring, isTruthy } from '../helpers/utils';\nimport { Decimals, Reference, SegmentClass, SingleFact } from '../interface/fact';\nimport { All, ErrorResponse, FMResponse, FetchMergeArgs } from '../interface/fetch-merge';\nimport { FilingSummary } from '../interface/filing-summary';\nimport { FormInformation } from '../interface/form-information';\nimport { UnitsAdditional } from '../interface/instance';\nimport { Context, DeiAmendmentFlagAttributes, Instance, LinkFootnote, LinkFootnoteArc, LinkLOC, Units } from '../interface/instance';\nimport { InstanceFile, MetaLinks, MetaLinksResponse, XhtmlFileMeta } from '../interface/instance-file';\nimport { Calculation, Meta, Section } from '../interface/meta';\nimport { UrlParams } from '../interface/url-params';\nimport { XhtmlPrepData, XhtmlPrepper } from './prepare-inline-doc';\nimport { buildSectionsArrayFlatter, fetchJson, fetchText, setScaleInfo } from './merge-data-utils';\n\n/* Created by staff of the U.S. Securities and Exchange Commission.\n * Data and content created by government employees within the scope of their employment\n * are not subject to domestic copyright protection. 17 U.S.C. 105.\n */\n\n\n/* eslint-disable @typescript-eslint/ban-types */\n\nexport class FetchAndMerge {\n    private absolute: string;\n    private params: UrlParams;\n    private customPrefix: string | null;\n    private activeInstance: InstanceFile = {} as any;\n    private std_ref;\n    private sections: Array<Section> = [];\n    private metaVersion: string | null = null;\n    private instances: InstanceFile[];\n\n    constructor(input: FetchMergeArgs) {\n        this.absolute = input.absolute;\n        this.params = input.params;\n        this.customPrefix = input.customPrefix || null;\n        this.instances = input.instance ?? [];\n        this.std_ref = input.std_ref;\n    }\n\n    public async fetch(): Promise<FMResponse> {\n        const docsAndInstance = () => {\n            return Promise.all([this.fetchDocs(), this.fetchInstanceXml()]).then(async ([docs, instXml]) => {\n                const errors = [...docs, instXml].filter((element): element is ErrorResponse =>\n                    element ? Object.prototype.hasOwnProperty.call(element, 'error') : false);\n\n                if (errors.length) {\n                    const errorMessages = errors.map(current => current.messages);\n                    throw { all: { error: true, messages: errorMessages.flat() } };\n                }\n\n                //At this point, neither of the responses had errors, so we can safely cast them\n                docs = docs as Array<{ xhtml: string }>;\n                instXml = instXml as Instance;\n\n                docs.filter((doc): doc is { xhtml: string } => \"xhtml\" in doc)\n                    .forEach((doc, index) => {\n                        this.activeInstance.docs[index].loaded = true;\n                        this.activeInstance.docs[index].xhtml = doc.xhtml;\n                    });\n\n                this.activeInstance.xml = instXml;\n            });\n        };\n\n        const metaAndSummary = () => {\n            return Promise.all([this.fetchMeta(), this.fetchSummary()]).then(([ml, fs]) => {\n                let error = false;\n                const messages = [];\n                for (const response of [ml, fs]) {\n                    if (\"error\" in response && response.error) {\n                        messages.push(response.messages);\n                        error = true;\n                    }\n                }\n                if (error) {\n                    throw { all: { error, messages: messages.flat() } };\n                }\n\n                //At this point, neither of the responses had errors, so we can safely cast them\n                const metalinks = ml as MetaLinks & { instances: InstanceFile[] };\n                const filingSummary = fs as FilingSummary;\n\n                this.metaVersion = metalinks.version || null;\n                this.std_ref = metalinks.std_ref || {} as any;\n\n                this.activeInstance = metalinks.instance;\n\n                return [metalinks, filingSummary] as const;\n            });\n        };\n\n        /** Sets each instance's `xmlUrl` to the correct value  */\n        const getInstanceXmlUrlFromFilingSummary = (filingSummary: FilingSummary, instances: InstanceFile[]) => {\n            const filingSummaryReports = filingSummary.MyReports.Report;\n        \n            //track which HTML slugs we've seen already\n            const instanceHtmSlugs = new Set<string>();  // stored in filing summary as foo.htm\n            filingSummaryReports.forEach((r) => {\n                const reportInstanceHtmSlug = r._attributes?.instance;\n                if (reportInstanceHtmSlug && !instanceHtmSlugs.has(reportInstanceHtmSlug)) {\n                    instanceHtmSlugs.add(reportInstanceHtmSlug);\n\n                    // add xmlUrls to instances\n                    const [metaInstanceModel] = instances.filter((inst) => inst.instanceHtm.includes(reportInstanceHtmSlug));\n                    metaInstanceModel.xmlUrl = this.params.metalinks.replace('MetaLinks.json', reportInstanceHtmSlug.replace('.htm', '_htm.xml'));\n                }\n            });\n\n            //At this point, if the active instance has an invalid `xmlUrl`, we cannot continue\n            if (!this.activeInstance?.xmlUrl) {\n                throw new Error('Could not determine instance URL of active instance.');\n            }\n        }\n\n        try {\n            let metalinks: (MetaLinks & { instances: InstanceFile[]}) | null = null;\n            this.activeInstance = this.instances.filter((element) => element.current)[0];\n            const initialLoad = this.activeInstance == null;\n            let isNcsr = false;\n\n            if (initialLoad) {\n                const [meta, summ] = await metaAndSummary();\n                getInstanceXmlUrlFromFilingSummary(summ, meta.instances);\n                \n                // iterate over FilingSummary.xml Reports to build sections, adding data from metalinks\n                this.sections = buildSectionsArrayFlatter(summ, Object.values(meta.sections), this.metaVersion || \"\");\n                this.setSectionGroupType(this.sections);\n\n                metalinks = meta;\n                this.instances = metalinks.instances;\n\n                if (!Array.isArray(summ.InputFiles?.File)) summ.InputFiles.File = [summ.InputFiles?.File];\n                \n                isNcsr = summ.InputFiles?.File?.reduce((acc, { _attributes }) => {\n                    return acc || _attributes?.isNcsr == \"true\";\n                }, isNcsr);\n            }                                        \n\n            await docsAndInstance();\n\n            // this is returned to the webworker\n            return { xhtml: this.activeInstance.docs.find((x) => x.current)?.xhtml || \"\", isNcsr };\n        }\n        catch(e) { this.errorHandling(e) }\n    }\n\n    public async facts(): Promise<FMResponse> {\n        try {\n            return { facts: this.buildFactMap() };\n        }\n        catch (e) { this.errorHandling(e) }\n    }\n\n    public async merge(): Promise<All> {\n        try {\n            await this.mergeAllResponses();\n\n            const all = {\n                instance: this.instances,\n                sections: this.sections,\n                std_ref: this.std_ref,\n            };\n\n            return { all };\n        }\n        catch (e) { this.errorHandling(e) }\n    }\n\n    private errorHandling(e: unknown): never {  \n        console.error(e);\n\n        if (!!e && typeof e == \"object\" && \"all\" in e)\n            throw e as All;\n        else if (e instanceof Error)\n            throw { all: { error: true, messages: [e.message] } };\n        else\n            throw { all: { error: true, messages: [JSON.stringify(e)] } };\n    }\n\n    private decodeWorkstationXmlInHtml(isWorkstation: boolean, html: string, closingXml: string) {\n        if (!isWorkstation) return html; // not running on SEC EDGAR workstation which encodes xml in HTML\n\n        if (!html.substring(0,100).toLowerCase().includes(\"<html><head>\")) {\n            if (html.includes(\"<title>EDGAR SEC Workstation Login</title>\")) {\n                console.error(\"Workstation requires logging in\");\n                window.alert(\"Workstation requires logging in\");\n                return \"\";\n            }\n            return html; // it's xml, not html\n        }\n\n        // snip extraneous html from beginning and end of response which is present in versions of files on workstation\n        // only 5 encodings are used in xml\n        html = html.replaceAll('&lt;', '<');\n        html = html.replaceAll('&gt;', '>');\n        html = html.replaceAll('&quot;', '\"');\n        html = html.replaceAll('&apos;', '\\'');\n        html = html.replaceAll('&amp;', '&');\n        return html.substring(html.indexOf(\"<?xml version=\"), html.indexOf(closingXml) + closingXml.length)\n    }\n\n    /**\n     * Description\n     * @returns {any} => current .htm file (xhtml file) || \"Doc\"\n     */\n    private fetchDocs(): Promise<Array<{ xhtml: string } | ErrorResponse>> {\n        const promises = this.activeInstance?.docs?.map((doc: { url: string }) => {\n            return new Promise<{ xhtml: string } | ErrorResponse>((resolve) => {\n                //TODO: use `HelpersUrl.isWorkstation` instead\n                const isWorkstation = doc.url.includes(\"DisplayDocument.do?\");\n                let ixvUrl = doc.url;\n                if (isWorkstation) {\n                    if (Object.prototype.hasOwnProperty.call(this.params, 'redline') && this.params.redline) {\n                        ixvUrl = ixvUrl.replace('.htm', '_ix2.htm');\n                    } else {\n                        ixvUrl = ixvUrl.replace('.htm', '_ix1.htm');\n                    }\n                }\n\n                const params: RequestInit = {\n                    headers: { \"Content-Type\": \"application/xhtml+xml\" },\n                    mode: 'no-cors',\n                    credentials: 'include',\n                };\n\n                fetchText(ixvUrl, params)\n                    .then((text) => {\n                        // on SEC EDGAR workstation xhtml is encoded like this: <HTML><HEAD><TITLE> ... &lt;?xml ...\n                        const xhtmlData = this.decodeWorkstationXmlInHtml(isWorkstation, text, \"</html>\");\n                        resolve({ xhtml: xhtmlData });\n                    })\n                    .catch((error) => {\n                        resolve({ error: true, messages: [`${error}; could not find \"${this.params.doc}\"`] });\n                    });\n            });\n        });\n\n        if (!promises)\n            return Promise.resolve([{ error: true, messages: [\"Issue fetching XHTMLs\"] }]);\n        else\n            return Promise.all(promises);\n    }\n\n    private fetchMeta(): Promise<ErrorResponse | (MetaLinks & { instances: InstanceFile[] })> {\n        //TODO: use async/await to simplify this logic\n        return new Promise<(MetaLinks & { instances: InstanceFile[] }) | ErrorResponse>((resolve) => {\n            let jsonUrl = this.params.metalinks;\n            //TODO: use `HelpersUrl.isWorkstation` instead\n            const isWorkstation = jsonUrl.includes(\"DisplayDocument.do?\");\n            if (isWorkstation) {\n                if (Object.prototype.hasOwnProperty.call(this.params, 'redline') && this.params.redline) {\n                    jsonUrl = jsonUrl.replace('MetaLinks.json', 'PrivateMetaLinks.json');\n                }\n            }\n\n            return fetchJson(jsonUrl, { credentials: 'include', mode: 'same-origin' })\n                .then((mlData: MetaLinksResponse) => {\n                    let XHTMLSlug = this.params.doc.substring(this.params.doc.lastIndexOf('/') + 1);\n                    if (XHTMLSlug.startsWith(\"DisplayDocument.do\") || XHTMLSlug.startsWith(\"view.html\")) {\n                        XHTMLSlug = this.params.doc.substring(this.params.doc.lastIndexOf('filename=') + 9);\n                    }\n\n                    const instanceFileNames = Object.keys(mlData.instance).join().split(/[ ,]+/);\n                    let sections = {};\n                    if (instanceFileNames.includes(XHTMLSlug)) {\n                        const instanceObjects: InstanceFile[] = Object.entries(mlData.instance).map(([currentInstance, instData], instanceIndex) => {\n                            // Sections\n                            //TODO: combine these using `Object.entries`\n                            Object.keys(instData.report).forEach((report) => {\n                                instData.report[report].instanceIndex = instanceIndex; // why?\n                            });\n                            Object.values(instData.report).forEach(report => {\n                                report.instanceHtm = currentInstance;\n                            });\n\n                            //NOTE: `sections` get reassigned at every step of this loop, is unused in the rest of the logic\n                            //  per loop step, and gets returned (the last value to which it's assigned) once the loop ends\n                            sections = Object.assign(sections, instData.report);\n\n                            /* \n                                if instance key has space, e.g. \n                                    \"doc1.htm doc2.htm\": {...}, \n                                it is known as multi doc.\n                            */\n                            const xhtmls: XhtmlFileMeta[] = currentInstance.split(' ').map((element) => {\n                                return {\n                                    slug: element,\n                                    url: this.params.doc.replace(this.params['doc-file'], element),\n                                    xhtml: null as any,\n                                    current: currentInstance.split(' ').includes(XHTMLSlug) && element === this.params['doc-file'],\n                                    loaded: false,\n                                };\n                            });\n\n                            const instFile: InstanceFile = {\n                                current: currentInstance.split(' ').includes(XHTMLSlug),\n                                instance: instanceIndex, // Why?\n                                map: new Map<string, SingleFact>(),\n                                metaInstance: Object.assign(instData),\n                                instanceHtm: currentInstance,\n                                xmlUrl: null as any,\n                                docs: xhtmls,\n                                formInformation: {} as FormInformation,\n                                xmlSlugs: [],\n                            };\n\n                            return instFile;\n                        });\n\n                        const [instance] = instanceObjects.filter(({ current }) => current);\n                        const meta: MetaLinks = { ...mlData, instance, sections, version: mlData.version, meta: {} as Meta, inlineFiles: [] };\n                        resolve(Object.assign(meta, { instances: instanceObjects }));\n                    } else {\n                        // this may occur when transferring a filing from one domain to another.  Not sure how to fix...\n                        if (!PRODUCTION) {\n                            console.log('instanceFileNames does not include XHTMLSlug. fetch-merge > fetchMeta())')\n                        }\n                        throw new Error('Incorrect MetaLinks.json Instance');\n                    }\n                })\n                .catch((error) => resolve({ error: true, messages: [`${error}; could not find \"${this.params.metalinks}\"`] }));\n        });\n    }\n\n    private fetchSummary(): Promise<FilingSummary | ErrorResponse> {\n        let filingSummXmlUrl = this.params.summary;\n\n        //TODO: use the new `isWorkstation` func in HelpersUrl instead\n        const isWorkstation = filingSummXmlUrl.includes(\"DisplayDocument.do?\");\n        if (isWorkstation && this.params.redline) {\n            filingSummXmlUrl = filingSummXmlUrl.replace('FilingSummary.xml', 'PrivateFilingSummary.xml');\n        }\n\n        return fetchText(filingSummXmlUrl, { credentials: 'include', mode: 'same-origin' })\n            .then((data) => {\n                const xmlData = this.decodeWorkstationXmlInHtml(isWorkstation, data, \"</FilingSummary>\");\n                const convertedXml = convert.xml2json(xmlData, { compact: true });\n                return JSON.parse(convertedXml).FilingSummary as FilingSummary;\n            })\n            .catch((error) => {\n                return ({ error: true, messages: [`${error}; could not find \"${this.params.summary}\"`] })\n            });\n    }\n\n    private fetchInstanceXml(): Promise<Instance | ErrorResponse> {\n        let xmlUrl = this.activeInstance?.xmlUrl;\n        if (!xmlUrl) return Promise.reject({ error: true, messages: [\"Issue fetching XML URLs\"] });\n        \n        const isWorkstation = xmlUrl.includes(\"DisplayDocument.do?\");\n        if (isWorkstation) {\n            // If methods from HelpersUrl are used here some very strange bugs occur, such as window and localStorage undefined.\n            if (Object.prototype.hasOwnProperty.call(this.params, 'redline') && this.params.redline) {\n                xmlUrl = xmlUrl.replace('_htm.xml', '_ht2.xml')\n            } else {\n                xmlUrl = xmlUrl.replace('_htm.xml', '_ht1.xml')\n            }\n        }\n\n        //TODO: we used to pass `{ credentials: 'include' }` to `.then()` (which is wrong);\n        //  should we be passing it to `fetchText`??\n        return fetchText(xmlUrl)\n            .then((text) => {\n                const fetchedXMlString = this.decodeWorkstationXmlInHtml(isWorkstation, text, \"</xbrl>\");\n\n                /*\n                    Parsing with arg {compact: true} results in json being in different order and no longer flat\n                */\n                const instanceXmlAsJsonCompact: Instance = JSON.parse(convert.xml2json(fetchedXMlString, { compact: true }));\n\n                if (instanceXmlAsJsonCompact.xbrl[\"link:footnoteLink\"] && DEBUGJS) {\n                    const footnotesNode = instanceXmlAsJsonCompact.xbrl[\"link:footnoteLink\"];\n                    // grab xml data as non compact object so element order is preserved.\n                    instanceXmlAsJsonCompact.xbrl[\"link:footnoteLink\"].expanded = JSON.parse(convert.xml2json(fetchedXMlString, { compact: false }));\n                    instanceXmlAsJsonCompact.xbrl[\"link:footnoteLink\"].orderedFootnoteDivs = footnotesNode.expanded.elements[0].elements;\n                    instanceXmlAsJsonCompact.xbrl[\"link:footnoteLink\"].asXmlString = cleanSubstring(fetchedXMlString, '<link:footnoteLink', '</link:footnoteLink>');\n                }\n\n                return instanceXmlAsJsonCompact;\n            })\n            .catch((error) => ({ error: true, messages: [`${error}; could not find \"XML Instance Data\"`] }));\n    }\n\n    private buildFactMap(): Map<string, SingleFact> {\n        if (!this?.activeInstance?.xml) throw new Error(\"Error: Active Instance has no XML data\");\n\n        // why set to index [0] ? !!!\n        // will this break on multidoc? !!!\n        this.activeInstance.map = this.buildInitialFactMap(this.activeInstance.xml);\n        this.enrichFactMapWithMetalinksData();\n\n        return this.activeInstance.map;\n    }\n\n    private async mergeAllResponses(): Promise<void> {\n        this.activeInstance.formInformation = this.extractFormInformation(this.activeInstance.metaInstance);\n        this.customPrefix = this.activeInstance.metaInstance.nsprefix?.toLowerCase() || null;\n        \n        const prepperData: XhtmlPrepData = {\n            docs: this.activeInstance.docs,\n            facts: this.activeInstance.map,\n            customPrefix: this.customPrefix || \"\",\n        };\n\n        await new XhtmlPrepper(prepperData).updateFactMapWithDocsData();\n    }\n\n    private buildInitialFactMap(instanceXml: Instance): Map<string, SingleFact> {\n        const getInstancePrefix = (instance: Instance) => {\n            const options = Object.keys(instance).filter(element => element.endsWith(':xbrl'))[0];\n            return options ? options.split(':')[0] : false;\n        };\n\n        const prefix = getInstancePrefix(instanceXml);\n        const instance: Record<string, any> = instanceXml;\n\n        const xbrlKey = prefix ? `${prefix}:xbrl` : 'xbrl';\n        const contextKey = prefix ? `${prefix}:context` : 'context';\n        const unitKey = prefix ? `${prefix}:unit` : 'unit';\n\n        const context = instance[xbrlKey][contextKey];\n        const unit = instance[xbrlKey][unitKey] || [];\n        const instanceFootnoteData = instance[xbrlKey]['link:footnoteLink'];\n\n        delete instance[xbrlKey][contextKey];\n        delete instance[xbrlKey][unitKey];\n        delete instance[xbrlKey]._attributes;\n        delete instance[xbrlKey]['link:schemaRef'];\n        delete instance[xbrlKey]['link:footnoteLink'];\n\n        this.setPeriodText(context);\n        this.setSegmentData(context);\n        this.setMeasureText(unit);\n\n        const factMap = new Map<string, SingleFact>();\n\n        const addFactToMap = (factElem: { _attributes: DeiAmendmentFlagAttributes; _text: string; }, tagName: string) => {\n            const attributes = factElem._attributes;\n            const id = `fact-identifier-${factCounter++}`;\n            const ix = attributes.id || id ;\n\n            factMap.set(ix, {\n                ...attributes,\n                ix,\n                id,\n                name: tagName,\n                value: this.isFactHTML(factElem._text) ? this.updateValueToRemoveIDs(factElem._text) : factElem._text,\n                isNegativeOnly: this.isFactNegativeOnly(factElem._text),\n                isHTML: this.isFactHTML(factElem._text),\n                period: this.setPeriodInfo(attributes.contextRef, context) || \"\",\n                periodDates: this.setPeriodDatesInfo(attributes.contextRef, context),\n                segment: this.setSegmentInfo(attributes.contextRef, context),\n                measure: this.setMeasureInfo(attributes.unitRef || \"\", unit),\n                scale: setScaleInfo(attributes.scale),\n                decimals: this.setDecimalsInfo(attributes.decimals || \"\"),\n                decimalsVal: attributes.decimals,\n                sign: null, // sign exists as attr in inlineDoc, not instance\n                footnote: this.setFootnoteInfo(ix, instanceFootnoteData),\n                isEnabled: true,\n                isHighlight: false,\n                isSelected: false,\n                filterContent: { content: this.getTextFromHTML(factElem._text) },\n                file: null,\n            });\n        }\n\n        let factCounter = 0;\n        for (const tagName in instance[xbrlKey]) {\n            const factElem = instance[xbrlKey][tagName];\n            /* example set of tagNames on instance.xbrl\n                _attributes\n                link:schemaRef\n                context\n                unit\n                dei:DocumentPeriodEndDate\n                dei:DocumentType\n                dei:EntityRegistrantName\n                dei:EntityCommonStockSharesOutstanding\n                i09203gd:Content4\n                link:footnoteLink\n            */\n            if (Array.isArray(factElem)) {\n                factElem.forEach((factEl: { _attributes: DeiAmendmentFlagAttributes; _text: string; }) => {\n                    addFactToMap(factEl, tagName);\n                });\n            } else {\n                addFactToMap(factElem, tagName);\n            }\n        }\n\n        return factMap;\n    }\n\n    private setSectionGroupType(sections: Section[]): Section[] {\n        // groupType is used in Metalinks v2.1 (and presumably earlier) and was replaced by menuCat in 2.2\n        if (Number(this.metaVersion) < 2.2) return sections;\n\n        this.sections.forEach((section) => section.groupType = section.menuCat);\n\n        return sections;\n    }\n\n    private extractFormInformation(meta: Meta): FormInformation {\n        const metaCopy = Object.assign({}, meta);\n        delete metaCopy.report;\n        delete metaCopy.tag;\n        return metaCopy as unknown as  FormInformation;\n    }\n\n    /**\n     * Description\n     * @returns {any} => updates instance fact map (this.activeInstance.map) with data from meta (this.activeInstance.metaInstance)\n     */\n    private enrichFactMapWithMetalinksData() {\n        const getRefFromMetalinks = (concept: string): string[] => {\n            const mlConcept = concept.replace(':', '_');\n            if (this.activeInstance?.metaInstance?.tag && this.activeInstance.metaInstance.tag[mlConcept]) {\n                const ref = this.activeInstance.metaInstance.tag[mlConcept].auth_ref;\n                return Array.isArray(ref) ? ref : [ref];\n            }\n\n            return [];\n        }\n\n        const addDimensionRefToFactRefs = (seg: any, refKeys: string[]) => {\n            if (seg.dimension) refKeys.push(...getRefFromMetalinks(seg.dimension));\n            if (seg.member) refKeys.push(...getRefFromMetalinks(seg.member));\n            return refKeys;\n        }\n\n        this.activeInstance?.map.forEach((currentFact: SingleFact) => {\n            /* \n                @Doc: Fact 'tags' in metalinks.json vs fact 'names' in instance and doc files\n                facts are stored in metalinks.json under instance[<instanceName>].tags\n                Tags can be concepts or dimensions which are also qNames.\n                Some tag names look like:\n                    dei_AmendmentDescription\n                They have underscores, but in the instance and doc files they have colons:\n                    dei:AmendmentDescription\n            */\n            const factNameTag = currentFact.name.replace(':', '_');\n            const factObjectMl = this.activeInstance?.metaInstance?.tag ? this.activeInstance.metaInstance?.tag[factNameTag] : null;\n\n            if (factObjectMl) {\n\n                /* add references (if any) to each individual fact\n                including references via any dimension [name]\n                including references via any member [name] */\n                if (factObjectMl.auth_ref) {\n                    let referenceKeys = [...factObjectMl.auth_ref];\n\n                    if (currentFact.segment) {\n                        let refKeys: string[] = [];\n\n                        currentFact.segment.map((seg: any) => {\n                            if (Array.isArray(seg)) {\n                                seg.forEach((nestedSeg: any) => {\n                                    refKeys = addDimensionRefToFactRefs(nestedSeg, refKeys);\n                                })\n                            } else {\n                                refKeys = addDimensionRefToFactRefs(seg, refKeys);\n                            }\n                        })\n\n                        referenceKeys = referenceKeys.concat(refKeys.flat());\n                    }\n\n                    const references = [...new Set(referenceKeys)]\n                        .map((current) => this.std_ref[current])\n                        .filter(Boolean);\n\n                    currentFact.references = references.length > 0 ? references : null;\n\n                    // this order specifically for Fact References\n                    // any other key => value will be ignored and not shown to the user\n                    const requiredOrder = [\n                        `Publisher`,\n                        `Name`,\n                        `Number`,\n                        `IssueDate`, // listed in xbrl book but not sure if I should add\n                        `Chapter`,\n                        `Article`,\n                        `Note`,\n                        `Exhibit`,\n                        `Section`,\n                        `Subsection`,\n                        `Topic`,\n                        `SubTopic`,\n                        `Paragraph`,\n                        `Subparagraph`,\n                        `Sentence`,\n                        `Clause`,\n                        `Subclause`,\n                        `Example`,\n                        `Footnote`,\n                        `URI`,\n                        `URIDate`,\n                        `role`,\n                    ];\n\n                    if (currentFact.references) {\n                        const refsWithOrderedProps = currentFact.references.map((singleReference: Reference) => {\n                            return Object.keys(singleReference)\n                                .reduce((accumulator, current) => {\n                                    const index = requiredOrder.findIndex(element => element === current);\n                                    if (index !== -1) {\n                                        const returnObject = {};\n                                        returnObject[current] = singleReference[current];\n                                        accumulator[index] = returnObject;\n                                    }\n                                    return accumulator;\n                                }, new Array(Object.keys(singleReference).length).fill(null))\n                                .filter(Boolean);\n                        });\n                        currentFact.references = refsWithOrderedProps;\n                    }\n                }\n\n                // add calculations (if any) to each individual fact\n                if (factObjectMl.calculation) {\n                    const tempFactCalculation = factObjectMl.calculation;\n                    currentFact.calculations = [];\n                    for (const factCalculationProp in tempFactCalculation) {\n                        const result: Calculation[] = this.sections?.map(sectionElement => {\n                            if (sectionElement.role === factCalculationProp) {\n                                /*\n                                    Walter comment: \"Although I traced the root cause to a problem in entry point sbsef-fex, still, \n                                    user actions can cause this.sections to be unbound when switching from one instance to another via the instance menu.  \n                                    So, this section should probably make sure that this.sections is at least an empty list:\"\n                                */\n                                return [\n                                    {\n                                        label: 'Section',\n                                        value: sectionElement.longName,\n                                    },\n                                    {\n                                        label: 'Weight',\n                                        value: this.getCalculationWeight(tempFactCalculation[factCalculationProp].weight || 0),\n                                    },\n                                    {\n                                        label: 'Parent',\n                                        value: this.getCalculationParent(tempFactCalculation[factCalculationProp].parentTag || \"\"),\n                                    },\n                                ];\n                            }\n                        })\n                        .filter(isTruthy);\n\n                        //As usual, this is pushing the wrong type onto the array, but it's been working so why fix it  :eyeroll:\n                        currentFact.calculations.push(...result as any);\n                    }\n                } else {\n                    currentFact.calculations = [];\n                }\n\n                // add labels (if any) to each individual fact\n                if (factObjectMl.lang) {\n                    currentFact.labels = Object.values(factObjectMl.lang).map((lang) => {\n                        const oldObject = lang.role;\n                        const newObject = {} as LabelElement;\n                        for (const property in oldObject) {\n\n                            const result = property.replace(/([A-Z])/g, ' $1');\n                            const finalResult = result.charAt(0).toUpperCase() + result.slice(1);\n                            Object.assign(newObject, { [finalResult]: oldObject[property] });\n                        }\n                        return newObject\n                    });\n\n                    currentFact.filterContent.labels = currentFact.labels.reduce((accumulator: string, current) => {\n                        const tempCurrent = { ...current };\n                        delete tempCurrent.documentation;\n                        return `${accumulator} ${Object.values(tempCurrent).join(' ')}`;\n\n                    }, '');\n\n                    currentFact.filterContent.definitions = currentFact.labels.reduce((accumulator, current: { Documentation: string; }) => {\n                        return `${accumulator} ${current.Documentation}`;\n                    }, '');\n                }\n\n                // add credit / debit\n                if (factObjectMl.crdr) {\n                    const balance = factObjectMl.crdr;\n                    currentFact.balance = `${balance.charAt(0).toUpperCase()}${balance.slice(1)}`;\n                }\n\n                // add xbrltype\n                if (factObjectMl.xbrltype) {\n                    currentFact.xbrltype = factObjectMl.xbrltype;\n                }\n\n                // add additional info to each individual fact\n                //TODO: why aren't these set to \"\" instead of null?\n                currentFact.localname = factObjectMl.localname || null as any;\n                currentFact.nsuri = factObjectMl.nsuri || null as any;\n                currentFact.presentation = factObjectMl.presentation || null as any;\n                currentFact.xbrltype = factObjectMl.xbrltype || null as any;\n\n                currentFact.isAmountsOnly = this.isFactAmountsOnly((currentFact.value ? currentFact.value : ''), currentFact.scale);\n                currentFact.isTextOnly = !this.isFactAmountsOnly((currentFact.value ? currentFact.value : ''), currentFact.scale);\n\n            }\n        });\n    }\n\n    private updateValueToRemoveIDs(input: string) {\n        const $ = cheerio.load(input, { xml: false });\n        $('[id]').each(function () {\n            $(this).removeAttr('id');\n        });\n        // we also wrap the entirety of the html in a simple div\n        $('body').wrapInner('<div></div>');\n        return $.html('body');\n    }\n\n    private isFactAmountsOnly(input: string, scale?: string | null | undefined): boolean {\n        return /^-?\\d+\\d*$/.test(input) && scale != null;\n    }\n\n    private isFactNegativeOnly(input: string) {\n        return this.isFactAmountsOnly(input) && input.startsWith('-');\n    }\n\n    private isFactHTML(input: string) {\n        return /<\\/?[a-z][\\s\\S]*>/i.test(input);\n    }\n\n    private getTextFromHTML(input: string) {\n        if (this.isFactHTML(input)) {\n            const $ = cheerio.load(input);\n            return $.text();\n        }\n        return input;\n    }\n\n    private setPeriodText(context: Context[]) {\n        context = Array.isArray(context) ? context : [context];\n        context?.forEach((current) => {\n            if (current.period) {\n                if (current.period.instant) {\n                    const date = new Date(current.period.instant._text);\n                    current.period._array = [`${date.getUTCMonth() + 1}/${date.getUTCDate()}/${date.getUTCFullYear()}`];\n                    current.period._text = `As of ${date.getUTCMonth() + 1}/${date.getUTCDate()}/${date.getUTCFullYear()}`;\n\n                } else if (current.period.startDate && current.period.endDate) {\n                    const startDate = new Date(current.period.startDate._text);\n                    const endDate = new Date(current.period.endDate._text);\n\n                    const yearDiff = (endDate.getUTCFullYear() - startDate.getUTCFullYear()) * 12;\n\n                    let monthDiff = (endDate.getUTCMonth() - startDate.getUTCMonth()) + yearDiff;\n                    const dayDiff = endDate.getUTCDate() - startDate.getUTCDate();\n\n                    //If the difference in days is more than half a month, round up/down as appropriate\n                    if (dayDiff > 15) {\n                        monthDiff++;\n                    } else if (dayDiff < -15) {\n                        monthDiff--;\n                    }\n\n                    current.period._array =\n                    [\n                        `${startDate.getUTCMonth() + 1}/${startDate.getUTCDate()}/${startDate.getUTCFullYear()}`,\n                        `${endDate.getUTCMonth() + 1}/${endDate.getUTCDate()}/${endDate.getUTCFullYear()}`,\n                    ];\n\n                    if (monthDiff <= 0) {\n                        current.period._text = `${startDate.getUTCMonth() + 1}/${startDate.getUTCDate()}/${startDate.getUTCFullYear()} - ${endDate.getUTCMonth() + 1}/${endDate.getUTCDate()}/${endDate.getUTCFullYear()}`;\n                    } else {\n                        //JS counts Jan = UTCMonth-0, so add 1\n                        current.period._text = `${monthDiff} months ending ${endDate.getUTCMonth() + 1}/${endDate.getUTCDate()}/${endDate.getUTCFullYear()}`;\n                    }\n                } else {\n                    const log: Logger<ILogObj> = new Logger();\n                    log.error(`\\nFact Period is NEITHER Instant nor Start / End`);\n                }\n            }\n        });\n    }\n\n    private setPeriodInfo(contextRef: string, context: [Context]) {\n        // we go through and find the 'id' in context that equals contextRef\n        context = Array.isArray(context) ? context : [context];\n        const factContext = context?.find((element) => {\n            return element._attributes.id === contextRef;\n        });\n        if (factContext && factContext.period) {\n            return factContext.period._text;\n        }\n    }\n\n    private setPeriodDatesInfo(contextRef: string, context: [Context]) {\n        // we go through and find the 'id' in context that equals contextRef\n        context = Array.isArray(context) ? context : [context];\n        const factContext = context?.find((element) => {\n            return element._attributes.id === contextRef;\n        });\n        if (factContext && factContext.period) {\n            return factContext.period._array;\n        }\n    }\n\n    private getTagLabelFromMetalinks = (tag: string) => {\n        const mlDimTag = tag.replace(':', '_');\n        if (this.activeInstance?.metaInstance?.tag && this.activeInstance.metaInstance.tag[mlDimTag]) {\n            let engLang = this.activeInstance.metaInstance.tag[mlDimTag].lang?.['en-us'];\n            if (!engLang) engLang = this.activeInstance.metaInstance.tag[mlDimTag].lang?.['en-US'];\n            const label = engLang?.role?.label;\n            return label || tag;\n        }\n    }\n    \n    private setSegmentData(context: Context | undefined) {\n        // we want to think of these as aspects of a fact with key value pairs\n        // for typed members \n        //      - it's dimension value will be the type of axis it is\n        //      - it's member value will be the value on that axis\n        // Segment is a container tag for dimensional data.\n        // There is only one segment tag for a fact (stored in context), but segment can contain multiple dimension tags\n\n        /*\n        Example Typed Member as xml\n        <segment>\n            <xbrldi:typedMember dimension=\"sbs:SbsefTradgSysOrPltfmAxis\">\n                <sbs:SbsefTradgSysOrPltfmAxis.domain>\n                    1\n                </sbs:SbsefTradgSysOrPltfmAxis.domain>\n            </xbrldi:typedMember>\n        </segment>\n\n        example in json\n        {\n            sbs:SbsefTradgSysOrPltfmAxis.domain: {\n                _text: '1'\n            },\n            _attributes: {\n                dimension: 'sbs:SbsefTradgSysOrPltfmAxis'\n            }\n        }\n        */\n\n        /*\n        Example of Explicit Member \n\n        xml data:\n        <segment>\n            <xbrldi:explicitMember dimension=\"us-gaap:StatementClassOfStockAxis\">us-gaap:CommonStockMember</xbrldi:explicitMember>\n            <xbrldi:explicitMember dimension=\"dei:EntityListingsExchangeAxis\">exch:XCHI</xbrldi:explicitMember>\n        </segment>\n\n        json data (first one)\n        {\n            _attributes: {\n                dimension: 'us-gaap:StatementClassOfStockAxis'\n            }\n            _text: \"us-gaap:CommonStockMember\"\n        }\n\n        display as:\n        (dimension)                         (member)\n        Class of Stock [Axis]               Common Stock [Member]\n        Entity Listings, Exchange [Axis]    NEW YORK STOCK EXCHANGE, INC. [Member]\n\n        */\n\n\n        const context2 = Array.isArray(context) ? context : [context];\n        context2.forEach((ctx) => {\n            if (ctx.entity && ctx.entity.segment) {\n                const segment = ctx.entity.segment;\n                segment.data = Object.keys(segment).map((tag) => {\n                    const isExplicit = tag.endsWith('explicitMember');\n                    if (Array.isArray(segment[tag])) {\n                        return segment[tag].map((seg: { _attributes: { dimension: string; }; _text: string; }) => {\n                            const memberVal = seg._text\n                                ? seg._text\n                                : seg[Object.keys(seg).filter((element: string) => !element.startsWith('_'))[0]]?._text;\n                            const dimensionData = {\n                                axis: seg._attributes.dimension,\n                                dimension: seg._attributes.dimension,\n                                dimensionLabel: this.getTagLabelFromMetalinks(seg._attributes.dimension),\n                                type: isExplicit ? 'explicit' : 'implicit',\n                                member: memberVal\n                            };\n                            if (isExplicit) dimensionData.memberLabel = this.getTagLabelFromMetalinks(memberVal);\n                            return dimensionData;\n                        });\n                    } else {\n                        const memberVal = isExplicit \n                            ? segment[tag]._text\n                            : segment[tag][Object.keys(segment[tag])[1]]._text;\n                        const dimensionData = {\n                            axis: segment[tag]._attributes.dimension,\n                            dimension: segment[tag]._attributes.dimension,\n                            dimensionLabel: this.getTagLabelFromMetalinks(segment[tag]._attributes.dimension),\n                            type: isExplicit ? 'explicit' : 'implicit',\n                            member: memberVal\n                        };\n                        if (isExplicit) dimensionData.memberLabel = this.getTagLabelFromMetalinks(memberVal);\n                        return dimensionData;\n                    }\n                });\n            }\n        });\n    }\n\n    private setSegmentInfo(contextRef: string, context: Context[]): SegmentClass[] | undefined {\n        context = Array.isArray(context) ? context : [context];\n        const factContext = context?.find((e) => e._attributes.id === contextRef);\n        return factContext?.entity?.segment?.data;\n    }\n\n    private setMeasureText(unit: Units[]) {\n        if (!Array.isArray(unit)) {\n            unit = [unit];\n        }\n\n        //Note: we need to first trick TS into believing a Units is really a UnitsAdditional\n        //TODO: have `setMeasureText` take UnitsAdditional instead\n        unit.map(u => u as UnitsAdditional)\n            .forEach((current: UnitsAdditional) => {\n                if (current && current.measure) {\n                    const measure = current.measure._text.includes(':') ?\n                        current.measure._text.split(':')[1].toUpperCase() :\n                        current.measure._text.toUpperCase();\n                    current._text = measure;\n                } else if (current && current.divide) {\n                    const numerator = current.divide.unitNumerator.measure._text.includes(':') ?\n                        current.divide.unitNumerator.measure._text.split(':')[1].toUpperCase() :\n                        current.divide.unitNumerator.measure._text.toUpperCase();\n\n                    const denominator = current.divide.unitDenominator.measure._text.includes(':') ?\n                        current.divide.unitDenominator.measure._text.split(':')[1].toUpperCase() :\n                        current.divide.unitDenominator.measure._text.toUpperCase();\n\n                    current._text = `${numerator} / ${denominator}`;\n                }\n            });\n    }\n\n    private setMeasureInfo(unitRef: string, unit: Units): string | undefined {\n        if (unit)\n        {\n            const findMatchingUnit = (unitArray: Units[]) => unitArray.find((element) => element._attributes.id === unitRef);\n            const factUnit = Array.isArray(unit) ? findMatchingUnit(unit) : findMatchingUnit([unit]);\n\n            if (factUnit && (\"measure\" in factUnit || \"divide\" in factUnit))\n            {\n                //Note: I suspect that we want factUnit.[\"measure\" || \"divide\"]._text\n                return factUnit._text;\n            }\n        }\n    }\n\n    private setDecimalsInfo(decimals: string): Decimals | null {\n        const decimalsOptions: Record<string, Decimals> = {\n            \"-1\": Decimals.Tens,\n            \"-2\": Decimals.Hundreds,\n            \"-3\": Decimals.Thousands,\n            \"-4\": Decimals.TenThousands,\n            \"-5\": Decimals.HundredThousandths,\n            \"-6\": Decimals.Millions,\n            \"-7\": Decimals.TenMillions,\n            \"-8\": Decimals.HundredMillions,\n            \"-9\":  Decimals.Billions,\n            \"-10\": Decimals.TenBillions,\n            \"-11\": Decimals.HundredBillions,\n            \"-12\": Decimals.Trillions,\n            1: Decimals.Tenths,\n            2: Decimals.Hundredths,\n            3: Decimals.Thousandths,\n            4: Decimals.TenThousandths,\n            5: Decimals.HundredThousandths,\n            6: Decimals.Millionths,\n        };\n\n        return decimalsOptions[decimals] || null;\n    }\n\n    private setSignInfo(sign: string): string | null {\n        const signOptions: Record<string, string> = {\n            '-': 'Negative',\n            '+': 'Positive',\n        };\n        \n        return signOptions[sign];\n    }\n\n    /**\n     * Description\n     * @param {any} ftObj:object\n     * @param {any} result?:string|undefined\n     * @returns {any} concatenated text from all footnote nodes, joined by a ' '\n     */\n    private accumulateFootnoteText(ftObj: LinkFootnote | Record<string, unknown>, result = \"\") {\n        const truncateFootnoteTo = 100;\n\n        if (result?.length > truncateFootnoteTo) {\n            result = result.substring(0, truncateFootnoteTo).substring(0, result.lastIndexOf(\" \") + 1);\n            return result += ' ...';\n        }\n\n        Object.entries(ftObj).forEach(([key, value]) =>\n        {\n            if (key == \"_text\") {\n                result += String(value);\n            }\n            else if (Array.isArray(value)) {\n                value.forEach(childNode => {\n                    result = this.accumulateFootnoteText(childNode, result);\n                })\n            }\n            else if (key.substring(0,6) == \"xhtml:\") {\n                result = this.accumulateFootnoteText(value, result);\n            }\n        });\n\n        return result;\n    }\n\n    /**\n     * Description\n     * @param {any} id:string\n     * @param {any} instanceFootnotes:{\"link:loc\":LinkLOC[]\n     * @param {any} \"link:footnote\":LinkFootnote[];\"link:footnoteArc\":LinkFootnoteArc[];}\n     * @param {string} asXmlString footnotes part of fetched xml text\n     * @returns {any} renderable footnote text (or xml string) to be displayed in fact modal\n     * todo: handle incoming footnotes.asXmlString or footnotes.xmlExpanded to show all content (in order) instead of just text\n     * todo: handle images, tables, ...other html elements (currently just concatenating text content)\n     * the above todos are WIP and are handled when useFetchedFootnoteXmlStrings is set to true.\n     */\n    private setFootnoteInfo(id: string, instanceFootnotes: {\n        \"link:loc\": LinkLOC[],\n        \"link:footnote\": LinkFootnote[],\n        \"link:footnoteArc\": LinkFootnoteArc[],\n        \"asXmlString\": string,\n    }) {\n        if (instanceFootnotes && instanceFootnotes['link:footnoteArc']) {\n            /*\n                link:footnoteArc tags are link tags with xlink:from some fact id xlink:to some xlink:footnote id that contains actual footnote content.\n            */\n            const factFootnoteArcTags = Array.isArray(instanceFootnotes['link:footnoteArc'])\n                ? instanceFootnotes['link:footnoteArc'].filter((element) => element._attributes['xlink:from'] === id ) \n                : [instanceFootnotes['link:footnoteArc']].find((element) => element._attributes['xlink:from'] === id )\n            if (factFootnoteArcTags?.length) {\n                if (instanceFootnotes['link:footnote']) {\n                    if (Array.isArray(instanceFootnotes['link:footnote'])) {\n                        const footnoteTags = factFootnoteArcTags?.map(arcTag => arcTag._attributes['xlink:to'])\n                            .map(footnoteId => instanceFootnotes['link:footnote'].find((footnoteElem) => footnoteElem._attributes.id === footnoteId));\n\n                        const useFetchedFootnoteXmlStrings = false;\n                        const useParsedFootnote = !useFetchedFootnoteXmlStrings;\n\n                        if (useParsedFootnote) {\n                            if (Array.isArray(footnoteTags)) {\n                                const footnotesTexts = footnoteTags.map(footnote => {\n                                    return this.accumulateFootnoteText(footnote || {} as Record<string, unknown>);\n                                });\n                                return footnotesTexts.join('<br>');\n                            } else {\n                                return this.accumulateFootnoteText(footnoteTags || {} as Record<string, unknown>);\n                            }\n                        }\n\n                        // Rest of this if block is WIP for rendering all div types in footnote cell\n\n                        // GO FIND PART OF footnotes.xmlString that corresponds to actual footnote\n                        // return that substring ... so you can render it in fact-pages.ts\n                        // we only need '<link:footnote ... > string for each footnote to render\n                        // find all <link:footnote ... > xml strings and put in array\n                        // then find the one that matches the xlink:to value with its id\n\n                        const startTagRegex = /<link:footnote /gi; \n                        let startTagResults: RegExpExecArray | null = null;\n                        const footnoteStartIndices:number[] = [];\n                        while (!!(startTagResults = startTagRegex.exec(instanceFootnotes.asXmlString))) {\n                            footnoteStartIndices.push(startTagResults.index);\n                        }\n\n                        const endTagRegex = /<\\/link:footnote>/gi; \n                        let endTagResults: RegExpExecArray | null = null;\n                        const footnoteEndIndices:number[] = [];\n                        while (!!(endTagResults = endTagRegex.exec(instanceFootnotes.asXmlString))) {\n                            footnoteEndIndices.push(endTagResults.index + ('</link:footnote>').length);\n                        }\n\n                        const footnotesAsXmlStrings: string[] = [];\n\n                        footnoteStartIndices.forEach((start, indexInArrayOfStarts) => {\n                            const pluckedFootnote = instanceFootnotes.asXmlString.substring(start, footnoteEndIndices[indexInArrayOfStarts]);\n                            footnotesAsXmlStrings.push(pluckedFootnote);\n                        })\n\n                        const relevantFootnoteAsXmlString = footnotesAsXmlStrings.find(fn => {\n                            return fn.indexOf(factFootnoteArcTags._attributes['xlink:to']) != -1;\n                        })\n\n                        return relevantFootnoteAsXmlString;\n                    } else {\n                        // single footnote on instance\n                        // TODO we need way more cases\n                        //uhh, no we don't, because the first 2 cases cover EVERYTHING\n                        if (!Array.isArray(instanceFootnotes['link:footnote']._text)) {\n                            return instanceFootnotes['link:footnote']._text;\n                        } else if (Array.isArray(instanceFootnotes['link:footnote']._text)) {\n                            return instanceFootnotes['link:footnote']._text.join('');\n                        } else if (instanceFootnotes['link:footnote']['xhtml:span']) {\n                            return instanceFootnotes['link:footnote']['xhtml:span']._text;\n                        }\n                    }\n                }\n            }\n        }\n        return null;\n    }\n\n    private getCalculationWeight(weight: number) {\n        if (weight > 0)\n            return `Added to parent(${weight.toFixed(2)})`;\n        else if (weight < 0)\n            return `Substracted from parent(${weight.toFixed(2)})`;\n        else\n            return 'Not Available.';\n    }\n\n    private getCalculationParent(parent: string) {\n        if (parent) {\n            return parent.replace('_', ':');\n        }\n        return 'Not Available.';\n    }\n}\n","/* Created by staff of the U.S. Securities and Exchange Commission.\n * Data and content created by government employees within the scope of their employment\n * are not subject to domestic copyright protection. 17 U.S.C. 105.\n */\n\nimport { FetchAndMerge } from '../fetch-merge/fetch-merge';\n\n/*\ndata in \nconst fetchAndMergeArgs: FetchMergeArgs = {\n    params: HelpersUrl.getAllParams,\n    absolute: HelpersUrl.getFolderAbsUrl,\n    instance: changeInstance ? Constants.getInstances : null,\n    std_ref: Constants.getStdRef,\n};\nFrom docsAndInstance\n- this.activeInstance.xml = instXml]\n- [this.activeInstance.docs]\nfrom metaAndSummary\n- this.metaVersion = metalinks.version || null;\n- this.std_ref = metalinks.std_ref || {} as any;\n- this.activeInstance = metalinks.instance;\n*/\n\nself.onmessage = ({ data }) => {\n    const fetchAndMerge = new FetchAndMerge(data);\n    fetchAndMerge.fetch()\n        .then((data) => self.postMessage(data))\n        .then(() => fetchAndMerge.facts())\n        .then((data) => self.postMessage(data))\n        .then(() => fetchAndMerge.merge())\n        .then((data) => self.postMessage(data))\n        .catch((e) => setTimeout(() => { throw new Error(JSON.stringify(e)) }));\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [870,585], () => (__webpack_require__(2884)))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and chunks that the entrypoint depends on\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".bundle.\" + {\"585\":\"749f2ec6c2ff200c48cb\",\"870\":\"2be58e7a854ed7626abd\"}[chunkId] + \".min.js\";\n};","// This function allow to reference async chunks and chunks that the entrypoint depends on\n__webpack_require__.miniCssF = (chunkId) => {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.p = \"/ixviewer-plus/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t662: 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkixviewer_2\"] = self[\"webpackChunkixviewer_2\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["deferred","next","Balance","LabelEnum","Decimals","version","featureSet","appStart","loadPhaseComplete","appWindow","window","frameElement","id","parent","loadedViaRedirect","perfTableJs","perfTableDom","elapsedPerfTable","discretePerfTable","logPerfParam","unused","axesCount","membersCount","memberLimit","getSearchCriteria","isNcsr","scrollPosition","localStorage","getItem","hoverOption","getHTMLAttributes","getPaginationPerPage","getHtmlOverallFactsCount","getMetaSourceDocuments","getMetaTags","getInstances","getCurrentInstance","find","inst","current","getInlineFiles","sections","setSections","sessionStorage","setItem","JSON","stringify","getSectionsFromSessionStorage","sectionsFromLocal","parse","getStdRef","getFormInformation","getMetaCustomPrefix","getMetaDts","getMetaDocuments","input","getScrollPosition","document","getElementById","scrollTop","getNavBarsHeight","querySelector","offsetHeight","sideBarPaginationState","pageNumber","totalPages","isTruthy","t","Boolean","facts","noIdFactMap","this","getId","contextRef","name","m","Map","values","map","reduce","acc","nameCtxref","idList","get","push","set","key","shift","getFactAttrsFromAnchorProps","section","fact","instance","uniqueAnchor","file","baseRef","ancestors","firstAnchor","mapCategoryName","isStandard","lowerCaseKey","toLowerCase","noStatementCatNameMap","standardCatNameMap","fetchText","url","init","fetch","then","response","ok","Error","status","toString","contentType","headers","test","contentDisposition","text","setScaleInfo","scale","docs","customPrefix","idAllocator","FactIdAllocator","updateFactMapWithDocsData","promises","sort","a","b","doc","Promise","resolve","applyElementDataToFact","all","$","xhtml","factElements","Array","from","factElem","attr","updateMap","slug","error","element","docSlug","raw","format","isAdditional","parents","prop","endsWith","isCustom","split","isAmountsOnly","isTextOnly","isNegativeOnly","sign","continuedIDs","console","activeInstance","metaVersion","getTagLabelFromMetalinks","tag","mlDimTag","replace","metaInstance","engLang","lang","role","label","absolute","params","instances","std_ref","docsAndInstance","fetchDocs","fetchInstanceXml","instXml","errors","filter","Object","prototype","hasOwnProperty","call","length","messages","flat","forEach","index","loaded","xml","metaAndSummary","fetchMeta","fetchSummary","ml","fs","metalinks","filingSummary","getInstanceXmlUrlFromFilingSummary","filingSummaryReports","MyReports","Report","instanceHtmSlugs","Set","r","reportInstanceHtmSlug","_attributes","has","add","instanceHtm","includes","xmlUrl","initialLoad","meta","summ","metaLinksReports","filingSummaryInputFiles","InputFiles","File","isArray","reportsContainStatements","MenuCategory","_text","some","menuCategory","metaReport","Number","menuCat","fsRep","ShortName","shortName","getMenuCategoryFromFilingSumm","subGroupType","groupType","undefined","mrFact","ancestorsRelevant","reverse","join","inlineFactSelector","addFactProps","reportFileInfo","fileName","original","instanceDocName","doctype","addInstanceProps","menuCatMapped","position","pos","Position","getPositionFromFilingSumm","domId","sanitize","normalizedSelector","replaceAll","convertToSelector","buildSectionsArrayFlatter","setSectionGroupType","x","errorHandling","buildFactMap","e","merge","mergeAllResponses","message","decodeWorkstationXmlInHtml","isWorkstation","html","closingXml","substring","indexOf","alert","ixvUrl","redline","mode","credentials","xhtmlData","catch","jsonUrl","json","mlData","XHTMLSlug","lastIndexOf","startsWith","instanceFileNames","keys","instanceObjects","entries","instanceIndex","currentInstance","instData","report","assign","xhtmls","formInformation","xmlSlugs","inlineFiles","filingSummXmlUrl","summary","data","xmlData","convertedXml","compact","FilingSummary","reject","fetchedXMlString","instanceXmlAsJsonCompact","xbrl","buildInitialFactMap","enrichFactMapWithMetalinksData","extractFormInformation","nsprefix","prepperData","XhtmlPrepper","instanceXml","prefix","options","getInstancePrefix","xbrlKey","contextKey","unitKey","context","unit","instanceFootnoteData","setPeriodText","setSegmentData","setMeasureText","factMap","addFactToMap","tagName","attributes","factCounter","ix","value","isFactHTML","updateValueToRemoveIDs","isFactNegativeOnly","isHTML","period","setPeriodInfo","periodDates","setPeriodDatesInfo","segment","setSegmentInfo","measure","setMeasureInfo","unitRef","decimals","setDecimalsInfo","decimalsVal","footnote","setFootnoteInfo","isEnabled","isHighlight","isSelected","filterContent","content","getTextFromHTML","factEl","metaCopy","getRefFromMetalinks","concept","mlConcept","ref","auth_ref","addDimensionRefToFactRefs","seg","refKeys","dimension","member","currentFact","factNameTag","factObjectMl","referenceKeys","nestedSeg","concat","references","refsWithOrderedProps","singleReference","accumulator","findIndex","returnObject","fill","calculation","calculations","factCalculationProp","result","sectionElement","longName","getCalculationWeight","weight","getCalculationParent","parentTag","labels","oldObject","newObject","property","finalResult","charAt","toUpperCase","slice","tempCurrent","documentation","definitions","Documentation","crdr","balance","xbrltype","localname","nsuri","presentation","isFactAmountsOnly","each","removeAttr","wrapInner","instant","date","Date","_array","getUTCMonth","getUTCDate","getUTCFullYear","startDate","endDate","yearDiff","monthDiff","dayDiff","factContext","ctx","entity","isExplicit","memberVal","dimensionData","axis","dimensionLabel","type","memberLabel","u","divide","numerator","unitNumerator","denominator","unitDenominator","findMatchingUnit","unitArray","factUnit","Tens","Hundreds","Thousands","TenThousands","HundredThousandths","Millions","TenMillions","HundredMillions","Billions","TenBillions","HundredBillions","Trillions","Tenths","Hundredths","Thousandths","TenThousandths","Millionths","setSignInfo","accumulateFootnoteText","ftObj","String","childNode","instanceFootnotes","footnoteTags","arcTag","footnoteId","footnoteElem","toFixed","self","onmessage","fetchAndMerge","FetchAndMerge","postMessage","setTimeout","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","__webpack_exports__","O","chunkIds","fn","priority","notFulfilled","Infinity","i","fulfilled","j","every","splice","d","definition","o","defineProperty","enumerable","f","chunkId","miniCssF","obj","Symbol","toStringTag","p","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","pop"],"sourceRoot":""}